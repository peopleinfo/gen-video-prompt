<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>gen-video-prompt GUI</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/compressorjs@1.2.1/dist/compressor.min.js"></script>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0b0d12;
        --panel: #141828;
        --text: #e9eefc;
        --muted: #a9b2cc;
        --border: rgba(255, 255, 255, 0.12);
        --accent: #6aa6ff;
        --danger: #ff6a6a;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: var(--bg);
        color: var(--text);
      }
      header {
        padding: 16px 18px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), transparent);
      }
      header h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }
      header p {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
      }
      main {
        display: grid;
        grid-template-columns: 420px 1fr;
        gap: 12px;
        padding: 12px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      .panel h2 {
        margin: 0;
        padding: 12px 14px;
        font-size: 13px;
        border-bottom: 1px solid var(--border);
      }
      .panel .content {
        padding: 12px 14px;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 10px 0 6px;
      }
      input,
      select,
      textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text);
        outline: none;
      }
      textarea {
        min-height: 120px;
        resize: vertical;
      }
      button {
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(106, 166, 255, 0.18);
        color: var(--text);
        cursor: pointer;
        font-weight: 600;
      }
      button:hover {
        border-color: rgba(106, 166, 255, 0.55);
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .tabs {
        display: flex;
        gap: 10px;
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
      }
      .tab {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.18);
        cursor: pointer;
        font-size: 12px;
        color: var(--muted);
      }
      .tab[data-active="true"] {
        color: var(--text);
        border-color: rgba(106, 166, 255, 0.55);
        background: rgba(106, 166, 255, 0.18);
      }
      .tab[data-disabled="true"] {
        opacity: 0.45;
        cursor: not-allowed;
        border-color: var(--border);
        background: rgba(0, 0, 0, 0.12);
      }
      pre {
        margin: 0;
        padding: 14px;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        line-height: 1.45;
      }
      pre.loading {
        color: var(--muted);
        background: linear-gradient(
          110deg,
          rgba(255, 255, 255, 0.04) 8%,
          rgba(255, 255, 255, 0.12) 18%,
          rgba(255, 255, 255, 0.04) 33%
        );
        background-size: 200% 100%;
        animation: outputShimmer 1.2s linear infinite;
      }
      .toast-container {
        position: fixed;
        right: 16px;
        bottom: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 50;
      }
      .toast {
        background: rgba(20, 24, 40, 0.95);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.18s ease, transform 0.18s ease;
        max-width: min(320px, calc(100vw - 32px));
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
      .toast.error {
        border-color: rgba(255, 106, 106, 0.5);
        color: var(--danger);
      }
      .error {
        color: var(--danger);
      }
      @keyframes outputShimmer {
        from {
          background-position: 200% 0;
        }
        to {
          background-position: -200% 0;
        }
      }
      @media (max-width: 980px) {
        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>gen-video-prompt GUI</h1>
      <p>Local UI for your MCP server: prompts, tools, and resources.</p>
    </header>

    <main>
      <section class="panel">
        <div class="tabs">
          <div class="tab" id="tab-setup" data-active="true">Setup LLM</div>
          <div class="tab" id="tab-chat" data-active="false">Chat</div>
          <div class="tab" id="tab-prompts" data-active="false">Prompts</div>
          <div class="tab" id="tab-docs" data-active="false">Docs</div>
          <div class="tab" id="tab-tools" data-active="false">Tools</div>
        </div>

        <div class="content" id="view-setup">
          <label for="provider">Fill missing fields</label>
          <select id="provider">
            <option value="none">Template only (no LLM)</option>
            <option value="command" selected>Local CLI</option>
            <option value="ollama">Ollama (HTTP)</option>
            <option value="openai_compatible">OpenAI-compatible API</option>
          </select>

          <div id="providerCommand" style="display: none">
            <label for="commandPreset">CLI</label>
            <select id="commandPreset">
              <option value="codex" selected>Codex CLI</option>
              <option value="gemini">Gemini CLI</option>
              <option value="agent">Cursor Agent</option>
              <option value="custom">Other CLI</option>
            </select>

            <div id="codexModelRow">
              <label for="codexModelPreset">Select model and effort</label>
              <select id="codexModelPreset">
                <option value="">(default)</option>
                <option value="gpt-5.2-codex">gpt-5.2-codex (current)</option>
                <option value="gpt-5.1-codex-max">gpt-5.1-codex-max</option>
                <option value="gpt-5.1-codex-mini">gpt-5.1-codex-mini</option>
                <option value="gpt-5.2">gpt-5.2</option>
                <option value="custom">Custom...</option>
              </select>
              <div id="codexModelCustom" style="display: none">
                <label for="codexModel">Custom model</label>
                <input id="codexModel" placeholder="e.g. gpt-4.1" />
              </div>
              <div style="margin-top: 6px; font-size: 12px; color: var(--muted)">
                Access legacy models with Custom or via config.toml.
              </div>
            </div>

            <div id="codexSessionRow" style="margin-top: 10px">
              <label for="codexSessionMode">Codex session</label>
              <select id="codexSessionMode">
                <option value="new" selected>New topic (stateless)</option>
                <option value="resume_last">Resume last session</option>
              </select>
              <button id="btnCodexNewTopic" type="button" style="margin-top: 6px">New topic</button>
            </div>

            <div id="geminiModelRow" style="margin-top: 10px; display: none">
              <label for="geminiModelPreset">Gemini model</label>
              <select id="geminiModelPreset">
                <option value="">Auto (best for task)</option>
                <option value="gemini-2.5-pro">Pro (gemini-2.5-pro)</option>
                <option value="gemini-2.5-flash">Flash (gemini-2.5-flash)</option>
                <option value="gemini-2.5-flash-lite">Flash-Lite (gemini-2.5-flash-lite)</option>
                <option value="custom">Custom...</option>
              </select>
              <div id="geminiModelCustom" style="display: none">
                <label for="geminiModel">Custom model</label>
                <input id="geminiModel" placeholder="e.g. gemini-2.5-pro" />
              </div>
            </div>

            <div id="commandCustom" style="display: none">
              <label for="cmd">Command</label>
              <input id="cmd" placeholder="e.g. my-llm-cli" />
            </div>
            <!-- <label for="cmdArgs">Args (space-separated)</label>
            <input id="cmdArgs" disabled placeholder="Disabled for security" /> -->
            <div style="margin-top: 10px; font-size: 12px; color: var(--muted)">
              Enable by starting GUI with <code>ENABLE_COMMAND_LLM=1</code>.
            </div>
          </div>

          <div id="providerOllama" style="display: none">
            <label for="ollamaBaseUrl">Base URL</label>
            <input id="ollamaBaseUrl" placeholder="http://127.0.0.1:11434" />
            <label for="ollamaModel">Model</label>
            <input id="ollamaModel" placeholder="e.g. llama3.2" />
            <div style="margin-top: 10px; font-size: 12px; color: var(--muted)">
              Enable by starting GUI with <code>ENABLE_HTTP_LLM=1</code>.
            </div>
          </div>

          <div id="providerOpenAi" style="display: none">
            <label for="openaiBaseUrl">Base URL</label>
            <input id="openaiBaseUrl" placeholder="https://api.openai.com" />
            <label for="openaiModel">Model</label>
            <input id="openaiModel" placeholder="e.g. gpt-4o-mini" />
            <label for="openaiApiKey">API key</label>
            <input id="openaiApiKey" placeholder="sk-..." />
            <div style="margin-top: 10px; font-size: 12px; color: var(--muted)">
              Enable by starting GUI with <code>ENABLE_HTTP_LLM=1</code>. API key is stored in your browser localStorage.
            </div>
          </div>

          <div style="margin-top: 16px; padding: 12px; border: 1px solid var(--border); border-radius: 10px; background: rgba(255, 255, 255, 0.02)">
            <label style="margin-top: 0">Global Settings</label>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 4px">
            <input id="compressImages" type="checkbox" style="width: auto; margin: 0" />
            <label for="compressImages" style="margin: 0; cursor: pointer; color: var(--text)">Compress images when picking (faster upload)</label>
          </div>
          <div id="compressionSettings" style="margin-top: 12px; display: none; flex-direction: column; gap: 8px; padding-left: 26px; border-left: 2px solid var(--accent)">
            <div style="display: flex; justify-content: space-between; align-items: center">
              <label style="margin: 0; font-size: 0.85em; color: var(--text-dim)">Compression Quality</label>
              <span id="qualityValue" style="font-size: 0.85em; font-weight: bold; color: var(--accent)">0.8</span>
            </div>
            <input id="compressionQuality" type="range" min="0.1" max="1.0" step="0.05" value="0.8" style="width: 100%; margin: 0; height: 4px; background: var(--border); border-radius: 2px; appearance: none; cursor: pointer;" />
          </div>
        </div>

          <div class="row" style="margin-top: 16px; align-items: center">
            <div>
              <label for="llmStatus">LLM connection</label>
              <div id="llmStatus" style="font-size: 12px; color: var(--muted)">(not checked)</div>
            </div>
            <div style="display: flex; align-items: flex-end; gap: 8px">
              <button id="btnConnect">Connect</button>
            </div>
          </div>
        </div>

        <div class="content" id="view-chat" style="display: none">
          <label for="chatPrompt">Message</label>
          <textarea id="chatPrompt" placeholder="Ask the LLM a quick question..."></textarea>
          <label for="chatImages">Images (optional)</label>
          <input id="chatImages" type="file" accept="image/*" multiple />
          <div id="chatImagesList" style="margin-top: 6px; font-size: 12px; color: var(--muted)"></div>
          <button id="btnChatSend">Send</button>
          <div style="margin-top: 10px; font-size: 12px; color: var(--muted)">
            Response shows in the Output panel. Images are supported for Codex CLI.
          </div>
        </div>

        <div class="content" id="view-prompts" style="display: none">
          <label>Workspaces</label>
          <div id="workspaceTabs" style="display: flex; flex-wrap: wrap; gap: 8px"></div>
          <div style="margin-top: 6px; font-size: 12px; color: var(--muted)">
            Images are not preserved between workspaces.
          </div>

          <label for="promptName">Prompt</label>
          <select id="promptName"></select>

          <label for="story">Story / request</label>
          <textarea id="story" placeholder="Describe what you want..."></textarea>
          <label for="promptImages">Images (optional)</label>
          <input id="promptImages" type="file" accept="image/*" multiple />
          <div id="promptImagesList" style="margin-top: 6px; font-size: 12px; color: var(--muted)"></div>

          <label for="mode">Mode</label>
          <select id="mode">
            <option value="auto" selected>Auto-detect</option>
            <option value="story">Storytelling</option>
            <option value="meme">Meme / Funny / Viral</option>
            <option value="documentary">Documentary</option>
            <option value="history">History</option>
          </select>

          <div class="row">
            <div>
              <label for="duration">Total duration (seconds) *</label>
              <select id="duration" required>
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15" selected>15</option>
                <option value="20">20</option>
                <option value="30">30</option>
                <option value="60">1mn</option>
                <option value="120">2mn</option>
                <option value="custom">Custom…</option>
              </select>
              <input id="durationCustom" placeholder="Enter duration" style="display: none; margin-top: 8px" />
            </div>
            <div>
              <label for="partLengthSeconds">Part length (seconds)</label>
              <input id="partLengthSeconds" placeholder="15" />
            </div>
          </div>
          <div class="row">
            <div>
              <label for="resolution">Resolution</label>
              <select id="resolution">
                <option value="" selected>(default 1920x1080)</option>
                <option value="1920x1080">1920x1080</option>
                <option value="1280x720">1280x720</option>
                <option value="720x1280">720x1280</option>
                <option value="1792x1024">1792x1024</option>
                <option value="1024x1792">1024x1792</option>
                <option value="custom">Custom…</option>
              </select>
              <input
                id="resolutionCustom"
                placeholder="Enter resolution (e.g. 1920x1080)"
                style="display: none; margin-top: 8px"
              />
            </div>
            <div>
              <label for="aspect">Aspect ratio</label>
              <select id="aspect">
                <option value="">(leave blank)</option>
                <option value="16:9 landscape">16:9 landscape</option>
                <option value="9:16 portrait" selected>9:16 portrait</option>
                <option value="1:1 square">1:1 square</option>
                <option value="custom">Custom…</option>
              </select>
              <input id="aspectCustom" placeholder="Enter aspect ratio" style="display: none; margin-top: 8px" />
            </div>
          </div>

          <label for="style">Style</label>
          <input id="style" placeholder="cinematic realism, 65mm..." />

          <label for="camera">Camera</label>
          <input id="camera" placeholder="lens, framing, movement..." />

          <label for="lighting">Lighting</label>
          <input id="lighting" placeholder="time of day, key light..." />

          <label for="actionBeats">Action beats</label>
          <input id="actionBeats" placeholder="beat 1 → beat 2 → beat 3..." />

          <label for="quality">Quality</label>
          <input id="quality" placeholder="fps, grain, realism..." />

          <label for="audio">Audio</label>
          <input id="audio" placeholder="rain, distant traffic..." />

          <button id="btnGetPrompt">Get template</button>
          <button id="btnGenerate" style="margin-left: 8px">Generate (fill)</button>
          <button id="btnAbort" type="button" style="margin-left: 8px" disabled>Abort</button>
          <div id="status" style="margin-top: 10px; font-size: 12px; color: var(--muted)"></div>
        </div>

        <div class="content" id="view-docs" style="display: none">
          <button id="btnLoadDocs">List documents</button>
          <label for="docUri">Resource URI</label>
          <select id="docUri"></select>
          <button id="btnReadDoc">Read document</button>
          <div style="margin-top: 10px; font-size: 12px; color: var(--muted)">
            Tip: PDFs may be large; the viewer will show the start of the extracted text.
          </div>
        </div>

        <div class="content" id="view-tools" style="display: none">
          <button id="btnLoadTools">List tools</button>
          <label for="toolName">Tool</label>
          <select id="toolName"></select>
          <label for="toolArgs">Arguments (JSON)</label>
          <textarea id="toolArgs" placeholder="{\n  \"id\": \"some-doc.md\"\n}"></textarea>
          <button id="btnCallTool">Call tool</button>
        </div>
      </section>

      <section class="panel">
        <div class="tabs" style="border-bottom: 1px solid var(--border)">
          <div class="tab" id="tab-preview" data-active="true">Preview</div>
          <div class="tab" id="tab-output" data-active="false">Output</div>
          <div class="tab" id="tab-video" data-active="false">Preview Video</div>
        </div>
        <div
          id="outputActions"
          style="display: none; justify-content: flex-end; gap: 8px; padding: 8px 14px; border-bottom: 1px solid var(--border); align-items: center; flex-wrap: wrap"
        >
          <select id="partSelect" style="margin-top: 0; width: auto; min-width: 180px" disabled>
            <option value="">No parts detected</option>
          </select>
          <button id="btnCopyParts" type="button" style="margin-top: 0" disabled>Copy all parts</button>
          <button id="btnCopyOutput" type="button" style="margin-top: 0">Copy output</button>
          <div
            id="partImageInputs"
            style="display: none; gap: 8px; align-items: flex-end; flex-wrap: wrap; width: 100%"
          ></div>
        </div>
        <pre id="outputPreview">(ready)</pre>
        <pre id="output" style="display: none">(ready)</pre>
        <div id="videoPanel" style="display: none; padding: 14px">
          <label for="videoParts">Video parts (in order)</label>
          <input id="videoParts" type="file" accept="video/*" multiple />
          <div id="videoPartsList" style="margin-top: 6px; font-size: 12px; color: var(--muted)"></div>
          <div style="display: flex; align-items: center; gap: 8px; margin-top: 10px; flex-wrap: wrap">
            <button id="btnMergeVideos" type="button">Merge videos</button>
            <button id="btnClearVideos" type="button">Clear</button>
            <div id="videoStatus" style="font-size: 12px; color: var(--muted)"></div>
          </div>
          <div
            id="videoPreviewWrapper"
            style="width: min(360px, 100%); aspect-ratio: 9 / 16; margin-top: 10px; display: none"
          >
            <video id="videoPreview" controls style="width: 100%; height: 100%; object-fit: contain"></video>
          </div>
        </div>
      </section>
    </main>
    <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="true"></div>

    <script>
      const $ = (id) => document.getElementById(id);

      function isTabDisabled(name) {
        const el = $("tab-" + name);
        return el && el.dataset.disabled === "true";
      }

      function setTabDisabled(name, disabled) {
        const el = $("tab-" + name);
        if (!el) return;
        el.dataset.disabled = String(disabled);
        el.setAttribute("aria-disabled", String(disabled));
        if (disabled && el.dataset.active === "true") {
          setTab("setup");
        }
      }

      function setTab(active) {
        if (isTabDisabled(active)) {
          showToast("Connect an LLM to use Chat and Prompts.", "error");
          return;
        }
        const views = ["setup", "chat", "prompts", "docs", "tools"];
        for (const v of views) {
          $("tab-" + v).dataset.active = String(v === active);
          $("view-" + v).style.display = v === active ? "block" : "none";
        }
      }

      $("tab-setup").addEventListener("click", () => setTab("setup"));
      $("tab-chat").addEventListener("click", () => setTab("chat"));
      $("tab-prompts").addEventListener("click", () => setTab("prompts"));
      $("tab-docs").addEventListener("click", () => setTab("docs"));
      $("tab-tools").addEventListener("click", () => setTab("tools"));

      function setOutputTab(active) {
        const views = ["output", "preview", "video"];
        for (const v of views) {
          $("tab-" + v).dataset.active = String(v === active);
        }
        const outputEl = $("output");
        const previewEl = $("outputPreview");
        const videoPanel = $("videoPanel");
        if (outputEl) outputEl.style.display = active === "output" ? "block" : "none";
        if (previewEl) previewEl.style.display = active === "preview" ? "block" : "none";
        if (videoPanel) videoPanel.style.display = active === "video" ? "block" : "none";
        const actions = $("outputActions");
        if (actions) actions.style.display = active === "output" ? "flex" : "none";
      }

      $("tab-preview").addEventListener("click", () => setOutputTab("preview"));
      $("tab-output").addEventListener("click", () => setOutputTab("output"));
      $("tab-video").addEventListener("click", () => setOutputTab("video"));
      
      // Toggle compression settings visibility
      $("compressImages").addEventListener("change", (e) => {
        $("compressionSettings").style.display = e.target.checked ? "flex" : "none";
      });
      
      // Update quality value display
      $("compressionQuality").addEventListener("input", (e) => {
        $("qualityValue").textContent = e.target.value;
      });

      async function copyToClipboard(text) {
        if (!text) return false;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.style.position = "fixed";
        textarea.style.opacity = "0";
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        textarea.remove();
        return true;
      }

      function escapeHtml(text) {
        return (text || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;");
      }

      async function copyTextWithOptionalImage(text, imageFile) {
        if (!text) return { copied: false, usedImage: false };
        if (!imageFile) {
          await copyToClipboard(text);
          return { copied: true, usedImage: false };
        }
        const canWrite =
          navigator.clipboard?.write && typeof ClipboardItem !== "undefined";
        if (!canWrite) {
          await copyToClipboard(text);
          return { copied: true, usedImage: false };
        }
        const prepared = await normalizeImageForClipboard(imageFile);
        const mimeType = prepared.type || "image/png";
        if (ClipboardItem.supports && !ClipboardItem.supports(mimeType)) {
          await copyToClipboard(text);
          return { copied: true, usedImage: false };
        }
        const safeText = escapeHtml(text).replaceAll("\n", "<br>");
        const html = `<p>${safeText}</p>`;
        await navigator.clipboard.write([
          new ClipboardItem({
            "text/plain": new Blob([text], { type: "text/plain" }),
            "text/html": new Blob([html], { type: "text/html" }),
            [mimeType]: prepared,
          }),
        ]);
        return { copied: true, usedImage: true };
      }

      async function copyImageOnly(imageFile) {
        if (!imageFile) return false;
        const canWrite =
          navigator.clipboard?.write && typeof ClipboardItem !== "undefined";
        if (!canWrite) return false;
        const prepared = await normalizeImageForClipboard(imageFile);
        const mimeType = prepared.type || "image/png";
        if (ClipboardItem.supports && !ClipboardItem.supports(mimeType)) return false;
        await navigator.clipboard.write([
          new ClipboardItem({
            [mimeType]: prepared,
          }),
        ]);
        return true;
      }

      async function normalizeImageForClipboard(file) {
        const mimeType = file.type || "image/png";
        if (mimeType === "image/png") return file;
        if (typeof createImageBitmap === "function") {
          const bitmap = await createImageBitmap(file);
          const canvas = document.createElement("canvas");
          canvas.width = bitmap.width;
          canvas.height = bitmap.height;
          const ctx = canvas.getContext("2d");
          if (!ctx) throw new Error("Failed to render image.");
          ctx.drawImage(bitmap, 0, 0);
          if (bitmap.close) bitmap.close();
          return await new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (blob) resolve(blob);
              else reject(new Error("Failed to encode image."));
            }, "image/png");
          });
        }
        const img = new Image();
        const url = URL.createObjectURL(file);
        try {
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = url;
          });
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth || img.width;
          canvas.height = img.naturalHeight || img.height;
          const ctx = canvas.getContext("2d");
          if (!ctx) throw new Error("Failed to render image.");
          ctx.drawImage(img, 0, 0);
          return await new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (blob) resolve(blob);
              else reject(new Error("Failed to encode image."));
            }, "image/png");
          });
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      async function compressImage(file, quality = 0.8, maxWidth = 1280) {
        if (!file.type.startsWith("image/")) return file;
        
        // Use Compressor.js (extremely lightweight ~10KB and robust)
        if (typeof Compressor !== "undefined") {
          return new Promise((resolve) => {
            new Compressor(file, {
              quality: quality,
              maxWidth: maxWidth,
              success(result) {
                resolve(new File([result], file.name, {
                  type: result.type,
                  lastModified: Date.now(),
                }));
              },
              error(err) {
                console.warn("Compressor.js failed, falling back to canvas:", err);
                // Fallback to manual canvas compression
                manualCompress(file, quality, maxWidth).then(resolve);
              },
            });
          });
        }

        return manualCompress(file, quality, maxWidth);
      }

      function manualCompress(file, quality, maxWidth) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            let width = img.width;
            let height = img.height;
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              URL.revokeObjectURL(img.src);
              resolve(file);
              return;
            }
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(
              (blob) => {
                URL.revokeObjectURL(img.src);
                if (blob) {
                  const compressed = new File([blob], file.name, {
                    type: "image/jpeg",
                    lastModified: Date.now(),
                  });
                  resolve(compressed);
                } else {
                  resolve(file);
                }
              },
              "image/jpeg",
              quality
            );
          };
          img.onerror = () => {
            URL.revokeObjectURL(img.src);
            resolve(file);
          };
          img.src = URL.createObjectURL(file);
        });
      }

      async function handleImagePick(inputId, listId) {
        const input = $(inputId);
        if (!input || !input.files || !input.files.length) return;
        const compressEnabled = $("compressImages") && $("compressImages").checked;
        const quality = parseFloat($("compressionQuality").value) || 0.8;
        if (compressEnabled) {
          const originalFiles = Array.from(input.files);
          const compressedFiles = await Promise.all(originalFiles.map((f) => compressImage(f, quality)));
          const dt = new DataTransfer();
          compressedFiles.forEach((f) => {
            dt.items.add(f);
          });
          input.files = dt.files;
        }
        renderImagesList(inputId, listId);
      }

      function extractParts(text) {
        if (!text) return [];
        const lines = text.split(/\r?\n/);
        const parts = [];
        let current = null;
        for (const line of lines) {
          const match = line.match(/^Part\s+\d+\b/i);
          if (match) {
            if (current) {
              current.text = current.lines.join("\n").trim();
              if (current.text) parts.push(current);
            }
            current = { label: line.trim(), lines: [line] };
            continue;
          }
          if (current) current.lines.push(line);
        }
        if (current) {
          current.text = current.lines.join("\n").trim();
          if (current.text) parts.push(current);
        }
        return parts;
      }

      let outputParts = [];
      const partImageFiles = new Map();

      function renderPartImageInputs() {
        const container = $("partImageInputs");
        if (!container) return;
        container.innerHTML = "";
        if (!outputParts.length) {
          container.style.display = "none";
          return;
        }
        container.style.display = "flex";
        outputParts.forEach((part, index) => {
          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.flexDirection = "column";
          wrapper.style.gap = "4px";
          wrapper.style.minWidth = "160px";
          const label = document.createElement("label");
          const labelText = part.label || `Part ${index + 1}`;
          label.textContent = `${labelText} image`;
          label.style.fontSize = "12px";
          label.style.color = "var(--muted)";
          label.setAttribute("for", `partImage-${index}`);
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.id = `partImage-${index}`;
          const copyButton = document.createElement("button");
          copyButton.type = "button";
          copyButton.textContent = "Copy image";
          copyButton.style.marginTop = "0";
          copyButton.style.display = "none";
          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.textContent = "Remove image";
          removeButton.style.marginTop = "0";
          removeButton.style.display = "none";
          removeButton.style.borderColor = "var(--danger)";
          removeButton.style.background = "rgba(255, 106, 106, 0.2)";
          removeButton.style.color = "var(--danger)";
          input.addEventListener("change", async () => {
            const compressEnabled = $("compressImages") && $("compressImages").checked;
            const quality = parseFloat($("compressionQuality").value) || 0.8;
            if (compressEnabled && input.files && input.files.length) {
              const originalFiles = Array.from(input.files);
              const compressedFiles = await Promise.all(originalFiles.map((f) => compressImage(f, quality)));
              const dt = new DataTransfer();
              compressedFiles.forEach((f) => {
                dt.items.add(f);
              });
              input.files = dt.files;
            }
            const file = input.files && input.files[0] ? input.files[0] : null;
            if (file) {
              partImageFiles.set(index, file);
              copyButton.style.display = "inline-flex";
              removeButton.style.display = "inline-flex";
            } else {
              partImageFiles.delete(index);
              copyButton.style.display = "none";
              removeButton.style.display = "none";
            }
          });
          removeButton.addEventListener("click", () => {
            partImageFiles.delete(index);
            input.value = "";
            copyButton.style.display = "none";
            removeButton.style.display = "none";
            showToast(`Removed ${labelText} image.`);
          });
          copyButton.addEventListener("click", async () => {
            const file = partImageFiles.get(index);
            if (!file) return;
            try {
              if (!window.isSecureContext) {
                showToast("Image copy requires HTTPS (or localhost).", "error");
                return;
              }
              const copied = await copyImageOnly(file);
              if (copied) {
                showToast(`Copied ${labelText} image.`);
              } else {
                showToast("Image copy not supported in this browser.", "error");
              }
            } catch {
              showToast("Copy failed.", "error");
            }
          });
          wrapper.appendChild(label);
          wrapper.appendChild(input);
          wrapper.appendChild(copyButton);
          wrapper.appendChild(removeButton);
          container.appendChild(wrapper);
        });
      }

      function updateOutputParts(text, isError = false, isLoading = false) {
        const select = $("partSelect");
        const copyAll = $("btnCopyParts");
        if (!select || !copyAll) return;
        outputParts = [];
        partImageFiles.clear();
        select.innerHTML = "";
        if (isLoading) {
          select.disabled = true;
          copyAll.disabled = true;
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "Loading parts...";
          select.appendChild(opt);
          renderPartImageInputs();
          return;
        }
        if (isError || !text || !text.trim()) {
          select.disabled = true;
          copyAll.disabled = true;
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No parts detected";
          select.appendChild(opt);
          renderPartImageInputs();
          return;
        }
        outputParts = extractParts(text);
        if (!outputParts.length) {
          select.disabled = true;
          copyAll.disabled = true;
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No parts detected";
          select.appendChild(opt);
          renderPartImageInputs();
          return;
        }
        select.disabled = false;
        copyAll.disabled = false;
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select part to copy";
        select.appendChild(placeholder);
        outputParts.forEach((part, index) => {
          const opt = document.createElement("option");
          opt.value = String(index);
          opt.textContent = part.label || `Part ${index + 1}`;
          select.appendChild(opt);
        });
        select.value = "";
        renderPartImageInputs();
      }

      $("partSelect").addEventListener("change", async (event) => {
        const value = event.target.value;
        if (!value) return;
        const index = Number(value);
        if (!Number.isFinite(index) || !outputParts[index]) return;
        try {
          const imageFile = partImageFiles.get(index);
          const result = await copyTextWithOptionalImage(outputParts[index].text, imageFile);
          if (result.usedImage) {
            showToast(`Copied ${outputParts[index].label || `Part ${index + 1}`} with image.`);
          } else {
            showToast(`Copied ${outputParts[index].label || `Part ${index + 1}`}.`);
          }
        } catch {
          showToast("Copy failed.", "error");
        } finally {
          event.target.value = "";
        }
      });

      $("btnCopyParts").addEventListener("click", async () => {
        if (!outputParts.length) return;
        const text = outputParts.map((part) => part.text).join("\n\n");
        try {
          await copyToClipboard(text);
          showToast("Copied all parts.");
        } catch {
          showToast("Copy failed.", "error");
        }
      });

      $("btnCopyOutput").addEventListener("click", async () => {
        const text = $("output").textContent || "";
        if (!text) return;
        const btn = $("btnCopyOutput");
        const original = btn.textContent;
        try {
          await copyToClipboard(text);
          btn.textContent = "Copied";
          setTimeout(() => {
            btn.textContent = original;
          }, 1200);
        } catch {
          btn.textContent = "Failed";
          setTimeout(() => {
            btn.textContent = original;
          }, 1200);
        }
      });

      const PREVIEW_TEMPLATE = [
        "Part 1 (start–end s):",
        "Prompt: <...>",
        "Scene: <...>",
        "Style: <...>",
        "Camera: <...>",
        "Lighting: <...>",
        "Action beats: <...>",
        "Quality: <...>",
        "Audio (optional): <...>",
        "",
        "Repeat the Part block for each segment when Part length is provided.",
      ].join("\n");

      function setOutput(text, isError = false, isLoading = false) {
        const el = $("output");
        el.textContent = text;
        el.className = isError ? "error" : isLoading ? "loading" : "";
        updateOutputParts(text, isError, isLoading);
      }

      function showOutputLoading(text) {
        setOutputTab("output");
        setOutput(text, false, true);
      }

      function showToast(message, variant = "info") {
        const container = $("toastContainer");
        if (!container || !message) return;
        const toast = document.createElement("div");
        toast.className = `toast${variant === "error" ? " error" : ""}`;
        toast.textContent = message;
        container.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add("show"));
        const hideDelay = 2200;
        const removeDelay = hideDelay + 200;
        setTimeout(() => {
          toast.classList.remove("show");
        }, hideDelay);
        setTimeout(() => {
          toast.remove();
        }, removeDelay);
      }

      function setLlmStatus(text, isError = false) {
        const el = $("llmStatus");
        if (!el) return;
        el.textContent = text;
        el.className = isError ? "error" : "";
      }

      const WORKSPACE_KEY = "gen-video-prompt.gui.workspaces.v1";
      let llmConnected = false;
      let generateAbortController = null;
      let mergedVideoUrl = "";
      let workspaces = [];
      let activeWorkspaceId = "";

      function updateLlmTabs() {
        const disabled = !llmConnected;
        setTabDisabled("chat", disabled);
        setTabDisabled("prompts", disabled);
      }

      function setGenerateAbortEnabled(enabled) {
        const btn = $("btnAbort");
        if (!btn) return;
        btn.disabled = !enabled;
      }

      function clearVideoPreview() {
        const preview = $("videoPreview");
        if (preview) {
          preview.pause();
          preview.removeAttribute("src");
          const wrapper = $("videoPreviewWrapper");
          if (wrapper) wrapper.style.display = "none";
        }
        if (mergedVideoUrl) {
          URL.revokeObjectURL(mergedVideoUrl);
          mergedVideoUrl = "";
        }
      }

      function newWorkspace(name) {
        return {
          id: `ws_${Math.random().toString(16).slice(2)}`,
          name,
          fields: { duration: "15" },
          output: "",
        };
      }

      function loadWorkspaces() {
        try {
          const raw = localStorage.getItem(WORKSPACE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") return null;
          if (!Array.isArray(parsed.workspaces)) return null;
          return parsed;
        } catch {
          return null;
        }
      }

      function saveWorkspaces() {
        try {
          localStorage.setItem(
            WORKSPACE_KEY,
            JSON.stringify({ activeId: activeWorkspaceId, workspaces })
          );
        } catch {}
      }

      function getActiveWorkspace() {
        return workspaces.find((ws) => ws.id === activeWorkspaceId) || workspaces[0];
      }

      function renderWorkspaceTabs() {
        const container = $("workspaceTabs");
        if (!container) return;
        container.innerHTML = "";
        for (const ws of workspaces) {
          const btn = document.createElement("div");
          btn.className = "tab";
          btn.dataset.active = String(ws.id === activeWorkspaceId);
          btn.style.display = "flex";
          btn.style.alignItems = "center";
          btn.style.gap = "6px";
          const label = document.createElement("span");
          label.textContent = ws.name;
          label.style.whiteSpace = "nowrap";
          label.style.overflow = "hidden";
          label.style.textOverflow = "ellipsis";
          const close = document.createElement("button");
          close.type = "button";
          close.textContent = "x";
          close.title = "Close workspace";
          close.setAttribute("aria-label", "Close workspace");
          close.style.marginTop = "0";
          close.style.padding = "0 6px";
          close.style.borderColor = "var(--border)";
          close.style.background = "rgba(0, 0, 0, 0.35)";
          close.style.color = "var(--muted)";
          close.style.fontWeight = "700";
          close.style.lineHeight = "1.2";
          close.style.fontSize = "12px";
          close.style.display = workspaces.length > 1 ? "inline-flex" : "none";
          close.addEventListener("click", (event) => {
            event.stopPropagation();
            if (workspaces.length <= 1) return;
            const keep = workspaces.filter((w) => w.id !== ws.id);
            workspaces = keep;
            activeWorkspaceId = keep[0].id;
            renderWorkspaceTabs();
            applyPromptFields(getActiveWorkspace().fields);
            clearPromptImages();
            saveWorkspaces();
          });
          btn.addEventListener("click", () => switchWorkspace(ws.id));
          btn.appendChild(label);
          btn.appendChild(close);
          container.appendChild(btn);
        }
        const addBtn = document.createElement("div");
        addBtn.className = "tab";
        addBtn.dataset.active = "false";
        addBtn.style.display = "inline-flex";
        addBtn.style.alignItems = "center";
        addBtn.style.justifyContent = "center";
        addBtn.style.width = "32px";
        addBtn.style.padding = "8px 0";
        addBtn.textContent = "+";
        addBtn.title = "New workspace";
        addBtn.addEventListener("click", () => {
          const name = `Workspace ${workspaces.length + 1}`;
          const ws = newWorkspace(name);
          workspaces.push(ws);
          switchWorkspace(ws.id);
        });
        container.appendChild(addBtn);
      }

      function setSelectWithCustom(selectId, customId, value) {
        const sel = $(selectId);
        const custom = $(customId);
        if (!sel || !custom) return;
        const val = value || "";
        const hasOption = Array.from(sel.options).some((opt) => opt.value === val);
        if (!val) {
          sel.value = "";
          custom.value = "";
          custom.style.display = "none";
          return;
        }
        if (hasOption) {
          sel.value = val;
          custom.value = "";
          custom.style.display = "none";
        } else {
          sel.value = "custom";
          custom.value = val;
          custom.style.display = "block";
        }
      }

      function capturePromptFields() {
        return {
          promptName: $("promptName").value || "",
          story: $("story").value || "",
          mode: $("mode").value || "",
          duration: pickValue("duration", "durationCustom") || "",
          resolution: pickValue("resolution", "resolutionCustom") || "",
          aspect: pickValue("aspect", "aspectCustom") || "",
          partLengthSeconds: $("partLengthSeconds").value || "",
          style: $("style").value || "",
          camera: $("camera").value || "",
          lighting: $("lighting").value || "",
          actionBeats: $("actionBeats").value || "",
          quality: $("quality").value || "",
          audio: $("audio").value || "",
        };
      }

      function applyPromptFields(fields) {
        if (!fields) return;
        const set = (id, value) => {
          if (value === undefined || value === null) return;
          const el = $(id);
          if (!el) return;
          el.value = String(value);
        };
        set("promptName", fields.promptName);
        set("story", fields.story);
        set("mode", fields.mode || "auto");
        setSelectWithCustom("duration", "durationCustom", fields.duration || "15");
        setSelectWithCustom("resolution", "resolutionCustom", fields.resolution);
        setSelectWithCustom("aspect", "aspectCustom", fields.aspect);
        set("partLengthSeconds", fields.partLengthSeconds);
        set("style", fields.style);
        set("camera", fields.camera);
        set("lighting", fields.lighting);
        set("actionBeats", fields.actionBeats);
        set("quality", fields.quality);
        set("audio", fields.audio);
      }

      function clearPromptImages() {
        const input = $("promptImages");
        const list = $("promptImagesList");
        if (input) input.value = "";
        if (list) list.textContent = "";
      }

      function saveActiveWorkspaceFields() {
        const ws = getActiveWorkspace();
        if (!ws) return;
        ws.fields = capturePromptFields();
        saveWorkspaces();
      }

      function saveActiveWorkspaceOutput(text) {
        const ws = getActiveWorkspace();
        if (!ws) return;
        ws.output = text || "";
        saveWorkspaces();
      }

      function switchWorkspace(id) {
        const current = getActiveWorkspace();
        if (current) current.fields = capturePromptFields();
        activeWorkspaceId = id;
        const next = getActiveWorkspace();
        applyPromptFields(next ? next.fields : {});
        clearPromptImages();
        renderWorkspaceTabs();
        if (next && next.output) {
          setOutput(next.output);
        }
        saveWorkspaces();
      }

      function initWorkspaces() {
        const stored = loadWorkspaces();
        if (stored && Array.isArray(stored.workspaces) && stored.workspaces.length > 0) {
          workspaces = stored.workspaces;
          activeWorkspaceId = stored.activeId && workspaces.some((ws) => ws.id === stored.activeId)
            ? stored.activeId
            : workspaces[0].id;
        } else {
          workspaces = [newWorkspace("Workspace 1")];
          activeWorkspaceId = workspaces[0].id;
        }
        renderWorkspaceTabs();
        applyPromptFields(getActiveWorkspace().fields);
      }

      function renderImagesList(inputId, listId) {
        const input = $(inputId);
        const list = $(listId);
        if (!input || !list) return;
        const files = input.files ? Array.from(input.files) : [];
        if (!files.length) {
          list.textContent = "";
          return;
        }
        list.innerHTML = "";
        files.forEach((file, index) => {
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.marginTop = "4px";
          const name = document.createElement("span");
          name.style.flex = "1";
          name.style.minWidth = "0";
          const fileName = file.name;
          const maxName = 32;
          const displayName =
            fileName.length > maxName
              ? `${fileName.slice(0, 18)}...${fileName.slice(-8)}`
              : fileName;
          name.textContent = `${displayName} (${Math.round(file.size / 1024)} KB)`;
          name.title = fileName;
          name.style.whiteSpace = "nowrap";
          name.style.overflow = "hidden";
          name.style.textOverflow = "ellipsis";
          const remove = document.createElement("button");
          remove.type = "button";
          remove.textContent = "X";
          remove.title = "Remove";
          remove.setAttribute("aria-label", "Remove image");
          remove.style.marginLeft = "auto";
          remove.style.marginTop = "0";
          remove.style.padding = "2px 8px";
          remove.style.borderColor = "var(--danger)";
          remove.style.background = "rgba(255, 106, 106, 0.2)";
          remove.style.color = "var(--danger)";
          remove.style.fontWeight = "700";
          remove.style.fontSize = "12px";
          remove.style.lineHeight = "1";
          remove.addEventListener("click", () => {
            const dt = new DataTransfer();
            files.forEach((f, i) => {
              if (i !== index) dt.items.add(f);
            });
            input.files = dt.files;
            renderImagesList(inputId, listId);
          });
          row.appendChild(name);
          row.appendChild(remove);
          list.appendChild(row);
        });
      }

      function renderFilesList(inputId, listId, removeLabel = "Remove file") {
        const input = $(inputId);
        const list = $(listId);
        if (!input || !list) return;
        const files = input.files ? Array.from(input.files) : [];
        if (!files.length) {
          list.textContent = "";
          return;
        }
        list.innerHTML = "";
        files.forEach((file, index) => {
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.marginTop = "4px";
          const name = document.createElement("span");
          name.style.flex = "1";
          name.style.minWidth = "0";
          const fileName = file.name;
          const maxName = 32;
          const displayName =
            fileName.length > maxName
              ? `${fileName.slice(0, 18)}...${fileName.slice(-8)}`
              : fileName;
          name.textContent = `${displayName} (${Math.round(file.size / 1024)} KB)`;
          name.title = fileName;
          name.style.whiteSpace = "nowrap";
          name.style.overflow = "hidden";
          name.style.textOverflow = "ellipsis";
          const remove = document.createElement("button");
          remove.type = "button";
          remove.textContent = "X";
          remove.title = removeLabel;
          remove.setAttribute("aria-label", removeLabel);
          remove.style.marginLeft = "auto";
          remove.style.marginTop = "0";
          remove.style.padding = "2px 8px";
          remove.style.borderColor = "var(--danger)";
          remove.style.background = "rgba(255, 106, 106, 0.2)";
          remove.style.color = "var(--danger)";
          remove.style.fontWeight = "700";
          remove.style.fontSize = "12px";
          remove.style.lineHeight = "1";
          remove.addEventListener("click", () => {
            const dt = new DataTransfer();
            files.forEach((f, i) => {
              if (i !== index) dt.items.add(f);
            });
            input.files = dt.files;
            renderFilesList(inputId, listId, removeLabel);
          });
          row.appendChild(name);
          row.appendChild(remove);
          list.appendChild(row);
        });
      }

      function getImageNames(inputId) {
        const input = $(inputId);
        if (!input || !input.files) return [];
        return Array.from(input.files).map((file) => file.name);
      }

      async function readImages(inputId) {
        const input = $(inputId);
        if (!input || !input.files || input.files.length === 0) return [];
        const files = Array.from(input.files);
        const maxBytes = 10 * 1024 * 1024;
        const totalBytes = files.reduce((sum, f) => sum + f.size, 0);
        if (totalBytes > maxBytes) {
          throw new Error("Total image size exceeds 10MB.");
        }
        return await Promise.all(
          files.map(
            (file) =>
              new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                  const result = reader.result;
                  if (typeof result !== "string") {
                    reject(new Error("Failed to read image data."));
                    return;
                  }
                  const comma = result.indexOf(",");
                  const data = comma >= 0 ? result.slice(comma + 1) : "";
                  if (!data) {
                    reject(new Error("Invalid image data."));
                    return;
                  }
                  resolve({ name: file.name, type: file.type, data });
                };
                reader.onerror = () => reject(new Error("Failed to read image file."));
                reader.readAsDataURL(file);
              })
          )
        );
      }

      async function readVideos(inputId) {
        const input = $(inputId);
        if (!input || !input.files || input.files.length === 0) return [];
        const files = Array.from(input.files);
        const maxBytes = 200 * 1024 * 1024;
        const totalBytes = files.reduce((sum, f) => sum + f.size, 0);
        if (totalBytes > maxBytes) {
          throw new Error("Total video size exceeds 200MB.");
        }
        return await Promise.all(
          files.map(
            (file) =>
              new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                  const result = reader.result;
                  if (typeof result !== "string") {
                    reject(new Error("Failed to read video data."));
                    return;
                  }
                  const comma = result.indexOf(",");
                  const data = comma >= 0 ? result.slice(comma + 1) : "";
                  if (!data) {
                    reject(new Error("Invalid video data."));
                    return;
                  }
                  resolve({ name: file.name, type: file.type, data });
                };
                reader.onerror = () => reject(new Error("Failed to read video file."));
                reader.readAsDataURL(file);
              })
          )
        );
      }

      function base64ToBlob(base64, mimeType) {
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return new Blob([bytes], { type: mimeType });
      }

      function buildStoryWithImages(story, imageNames) {
        const base = (story || "").trim();
        if (!imageNames || imageNames.length === 0) return base;
        const labels = ["Character reference", "Start frame reference", "End frame reference"];
        const lines = imageNames.map((name, index) => {
          const label = labels[index] || "Additional reference";
          return `- ${label}: ${name}`;
        });
        const header = "Image references (use filenames as cues for character/start/end frames):";
        return [base, "", header, ...lines].filter(Boolean).join("\n");
      }

      function getCommandValue() {
        const preset = $("commandPreset");
        if (preset && preset.value === "codex") return "codex";
        if (preset && preset.value === "gemini") return "gemini";
        if (preset && preset.value === "agent") return "agent";
        return $("cmd").value || "";
      }

      function getCodexModelValue() {
        const preset = $("commandPreset");
        if (!preset || preset.value !== "codex") return "";
        const modelPreset = $("codexModelPreset");
        if (!modelPreset) return "";
        if (modelPreset.value === "custom") {
          return ($("codexModel").value || "").trim();
        }
        return (modelPreset.value || "").trim();
      }

      function getGeminiModelValue() {
        const preset = $("commandPreset");
        if (!preset || preset.value !== "gemini") return "";
        const modelPreset = $("geminiModelPreset");
        if (!modelPreset) return "";
        if (modelPreset.value === "custom") {
          return ($("geminiModel").value || "").trim();
        }
        return (modelPreset.value || "").trim();
      }

      function getCodexSessionMode() {
        const preset = $("commandPreset");
        if (!preset || preset.value !== "codex") return "";
        const mode = $("codexSessionMode");
        return mode ? mode.value || "new" : "new";
      }

      function collectLlmConfig() {
        return {
          provider: $("provider").value || "none",
          command: getCommandValue(),
          codex_model: getCodexModelValue(),
          codex_session: getCodexSessionMode(),
          gemini_model: getGeminiModelValue(),
          ollama: {
            base_url: $("ollamaBaseUrl").value || "",
            model: $("ollamaModel").value || "",
          },
          openai_compatible: {
            base_url: $("openaiBaseUrl").value || "",
            model: $("openaiModel").value || "",
            api_key: $("openaiApiKey").value || "",
          },
        };
      }

      async function api(path, options) {
        const res = await fetch(path, {
          ...options,
          headers: { "content-type": "application/json", ...(options && options.headers) },
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.ok === false) {
          const msg = data && data.error ? data.error : "Request failed";
          throw new Error(msg);
        }
        return data;
      }

      const SETTINGS_KEY = "gen-video-prompt.gui.settings.v1";

      function loadSettings() {
        try {
          const raw = localStorage.getItem(SETTINGS_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          return parsed && typeof parsed === "object" ? parsed : {};
        } catch {
          return {};
        }
      }

      function saveSettings(settings) {
        try {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        } catch {}
      }

      function applySettings(settings) {
        const set = (id, value) => {
          if (value === undefined || value === null) return;
          const el = $(id);
          if (!el) return;
          el.value = String(value);
        };
        set("provider", settings.provider);
        set(
          "commandPreset",
          settings.commandPreset ||
            (settings.cmd ? (settings.cmd === "codex" ? "codex" : settings.cmd === "gemini" ? "gemini" : "custom") : "codex")
        );
        const codexModel = typeof settings.codexModel === "string" ? settings.codexModel.trim() : "";
        const presetFromModel = codexModel
          ? ["gpt-5.2-codex", "gpt-5.1-codex-max", "gpt-5.1-codex-mini", "gpt-5.2"].includes(codexModel)
            ? codexModel
            : "custom"
          : "";
        set("codexModelPreset", settings.codexModelPreset || presetFromModel);
        set("codexModel", codexModel);
        set("codexSessionMode", settings.codexSessionMode || "new");
        const geminiModel = typeof settings.geminiModel === "string" ? settings.geminiModel.trim() : "";
        const geminiPresetFromModel = geminiModel
          ? ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-2.5-flash-lite"].includes(geminiModel)
            ? geminiModel
            : "custom"
          : "";
        set("geminiModelPreset", settings.geminiModelPreset || geminiPresetFromModel);
        set("geminiModel", geminiModel);
        set("cmd", settings.cmd);
        set("cmdArgs", "");
        set("ollamaBaseUrl", settings.ollamaBaseUrl);
        set("ollamaModel", settings.ollamaModel);
        set("openaiBaseUrl", settings.openaiBaseUrl);
        set("openaiModel", settings.openaiModel);
        set("openaiApiKey", settings.openaiApiKey);
        const compressEl = $("compressImages");
        if (compressEl) {
          compressEl.checked = settings.compressImages === true;
        }
      }

      function captureSettings() {
        return {
          provider: $("provider").value || "none",
          commandPreset: $("commandPreset").value || "codex",
          codexModelPreset: $("codexModelPreset").value || "",
          codexModel: $("codexModel").value || "",
          codexSessionMode: $("codexSessionMode").value || "new",
          geminiModelPreset: $("geminiModelPreset").value || "",
          geminiModel: $("geminiModel").value || "",
          cmd: $("cmd").value || "",
          cmdArgs: "",
          ollamaBaseUrl: $("ollamaBaseUrl").value || "",
          ollamaModel: $("ollamaModel").value || "",
          openaiBaseUrl: $("openaiBaseUrl").value || "",
          openaiModel: $("openaiModel").value || "",
          openaiApiKey: $("openaiApiKey").value || "",
          compressImages: $("compressImages") ? $("compressImages").checked : false,
        };
      }

      function words(str) {
        const s = (str || "").trim();
        if (!s) return [];
        return s.split(/\s+/g);
      }

      function pickValue(selectId, customId) {
        const sel = $(selectId);
        const custom = $(customId);
        const v = sel ? sel.value : "";
        if (!v) return undefined;
        if (v === "custom") {
          const cv = custom ? custom.value.trim() : "";
          return cv ? cv : undefined;
        }
        return v;
      }

      function getTotalDurationSeconds() {
        const raw = pickValue("duration", "durationCustom");
        if (!raw) return undefined;
        const num = Number(raw);
        return Number.isFinite(num) && num > 0 ? num : undefined;
      }

      function getPartLengthSeconds() {
        const raw = ($("partLengthSeconds").value || "").trim();
        if (!raw) return undefined;
        const num = Number(raw);
        return Number.isFinite(num) && num > 0 ? num : undefined;
      }

      function assertValidPartLength() {
        const total = getTotalDurationSeconds();
        const part = getPartLengthSeconds();
        if (part !== undefined && total !== undefined && part >= total) {
          throw new Error("Part length must be less than total duration.");
        }
      }

      function wireCustom(selectId, customId) {
        const sel = $(selectId);
        const custom = $(customId);
        if (!sel || !custom) return;
        const update = () => {
          custom.style.display = sel.value === "custom" ? "block" : "none";
        };
        sel.addEventListener("change", update);
        update();
      }

      async function loadPrompts() {
        const data = await api("/api/prompts", { method: "GET" });
        const select = $("promptName");
        select.innerHTML = "";
        for (const p of data.prompts || []) {
          const opt = document.createElement("option");
          opt.value = p.name;
          opt.textContent = `${p.title || p.name}`;
          select.appendChild(opt);
        }
      }

      async function loadTools() {
        const data = await api("/api/tools", { method: "GET" });
        const select = $("toolName");
        select.innerHTML = "";
        for (const t of data.tools || []) {
          const opt = document.createElement("option");
          opt.value = t.name;
          opt.textContent = `${t.name}`;
          select.appendChild(opt);
        }
      }

      async function loadDocs() {
        const data = await api("/api/resources", { method: "GET" });
        const select = $("docUri");
        select.innerHTML = "";
        for (const r of data.resources || []) {
          const opt = document.createElement("option");
          opt.value = r.uri;
          opt.textContent = `${r.name || r.uri}`;
          select.appendChild(opt);
        }
      }

      $("btnGetPrompt").addEventListener("click", async () => {
        $("status").textContent = "Loading...";
        try {
          assertValidPartLength();
          const name = $("promptName").value;
          const storyWithImages = buildStoryWithImages($("story").value, getImageNames("promptImages"));
          const body = {
            name,
            arguments: {
              story: storyWithImages,
              mode: $("mode").value || undefined,
              duration_seconds: getTotalDurationSeconds(),
              part_length_seconds: getPartLengthSeconds(),
              resolution: pickValue("resolution", "resolutionCustom"),
              aspect_ratio: pickValue("aspect", "aspectCustom"),
              style: $("style").value || undefined,
              camera: $("camera").value || undefined,
              lighting: $("lighting").value || undefined,
              action_beats: $("actionBeats").value || undefined,
              quality: $("quality").value || undefined,
              audio: $("audio").value || undefined,
            },
          };

          const data = await api("/api/prompts/get", { method: "POST", body: JSON.stringify(body) });
          const msg = (data.messages && data.messages[0] && data.messages[0].content) || null;
          const text = msg && msg.type === "text" ? msg.text : JSON.stringify(data, null, 2);
          setOutput(text);
          saveActiveWorkspaceOutput(text);
          $("status").textContent = "Done.";
        } catch (e) {
          $("status").textContent = "Error.";
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnAbort").addEventListener("click", () => {
        if (!generateAbortController) return;
        generateAbortController.abort();
        generateAbortController = null;
        setGenerateAbortEnabled(false);
        $("status").textContent = "Aborted.";
        setOutput("Aborted.");
        showToast("Generation aborted.");
      });

      $("btnGenerate").addEventListener("click", async () => {
        $("status").textContent = "Generating...";
        showOutputLoading("Generating...");
        if (generateAbortController) {
          generateAbortController.abort();
        }
        generateAbortController = new AbortController();
        setGenerateAbortEnabled(true);
        try {
          assertValidPartLength();
          const provider = $("provider").value || "none";
          const storyWithImages = buildStoryWithImages($("story").value, getImageNames("promptImages"));
          const payload = {
            provider,
            story: storyWithImages,
            mode: $("mode").value || undefined,
            duration_seconds: getTotalDurationSeconds(),
            part_length_seconds: getPartLengthSeconds(),
            resolution: pickValue("resolution", "resolutionCustom"),
            aspect_ratio: pickValue("aspect", "aspectCustom"),
            style: $("style").value || undefined,
            camera: $("camera").value || undefined,
            lighting: $("lighting").value || undefined,
            action_beats: $("actionBeats").value || undefined,
            quality: $("quality").value || undefined,
            audio: $("audio").value || undefined,
          };

          if (provider === "command") {
            payload.command = getCommandValue();
            payload.codex_model = getCodexModelValue() || undefined;
            payload.codex_session = getCodexSessionMode() || undefined;
            payload.gemini_model = getGeminiModelValue() || undefined;
            if (payload.command === "codex") {
              const images = await readImages("promptImages");
              if (images.length) {
                payload.images = images;
              }
            }
          }
          if (provider === "ollama") {
            payload.base_url = $("ollamaBaseUrl").value || undefined;
            payload.model = $("ollamaModel").value || undefined;
          }
          if (provider === "openai_compatible") {
            payload.base_url = $("openaiBaseUrl").value || undefined;
            payload.model = $("openaiModel").value || undefined;
            payload.api_key = $("openaiApiKey").value || undefined;
          }

          saveSettings(captureSettings());

          const data = await api("/api/generate", {
            method: "POST",
            body: JSON.stringify(payload),
            signal: generateAbortController.signal,
          });
          setOutput(data.text || JSON.stringify(data, null, 2));
          saveActiveWorkspaceOutput(data.text || JSON.stringify(data, null, 2));
          $("status").textContent = "Done.";
        } catch (e) {
          if (e && e.name === "AbortError") {
            $("status").textContent = "Aborted.";
            setOutput("Aborted.");
          } else {
            $("status").textContent = "Error.";
            setOutput(e && e.message ? e.message : String(e), true);
          }
        } finally {
          generateAbortController = null;
          setGenerateAbortEnabled(false);
        }
      });

      $("btnMergeVideos").addEventListener("click", async () => {
        const status = $("videoStatus");
        if (status) status.textContent = "Merging...";
        try {
          const files = await readVideos("videoParts");
          if (!files.length) {
            if (status) status.textContent = "Select video parts first.";
            return;
          }
          clearVideoPreview();
          const data = await api("/api/merge-videos", {
            method: "POST",
            body: JSON.stringify({ files }),
          });
          const file = data && data.file ? data.file : null;
          if (!file || !file.data) {
            throw new Error("Missing merged video data.");
          }
          const mimeType = file.type || "video/mp4";
          const blob = base64ToBlob(file.data, mimeType);
          mergedVideoUrl = URL.createObjectURL(blob);
          const preview = $("videoPreview");
          const wrapper = $("videoPreviewWrapper");
          if (preview) {
            preview.src = mergedVideoUrl;
            if (wrapper) wrapper.style.display = "block";
            preview.load();
          }
          if (status) status.textContent = "Merged.";
        } catch (e) {
          if (status) status.textContent = "Error.";
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnClearVideos").addEventListener("click", () => {
        const input = $("videoParts");
        if (input) input.value = "";
        renderFilesList("videoParts", "videoPartsList", "Remove video");
        const status = $("videoStatus");
        if (status) status.textContent = "";
        clearVideoPreview();
      });

      $("btnLoadDocs").addEventListener("click", async () => {
        try {
          await loadDocs();
          setOutput("Loaded documents.");
        } catch (e) {
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnReadDoc").addEventListener("click", async () => {
        try {
          const uri = $("docUri").value;
          const data = await api(`/api/resources/read?uri=${encodeURIComponent(uri)}`, { method: "GET" });
          const content = data.contents && data.contents[0] ? data.contents[0] : null;
          const text = content && content.text ? String(content.text) : JSON.stringify(data, null, 2);
          setOutput(text.slice(0, 20000) + (text.length > 20000 ? "\n\n...(truncated)..." : ""));
        } catch (e) {
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnLoadTools").addEventListener("click", async () => {
        try {
          await loadTools();
          setOutput("Loaded tools.");
        } catch (e) {
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnCallTool").addEventListener("click", async () => {
        try {
          const name = $("toolName").value;
          const raw = $("toolArgs").value.trim();
          let args = {};
          if (raw) args = JSON.parse(raw);
          const data = await api("/api/tools/call", {
            method: "POST",
            body: JSON.stringify({ name, arguments: args }),
          });
          setOutput(JSON.stringify(data, null, 2));
        } catch (e) {
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      $("btnConnect").addEventListener("click", async () => {
        const btn = $("btnConnect");
        if (llmConnected) {
          llmConnected = false;
          updateLlmTabs();
          setLlmStatus("Disconnected.", true);
          btn.textContent = "Connect";
          return;
        }
        try {
          btn.disabled = true;
          btn.textContent = "Checking...";
          setLlmStatus("Checking LLM...");
          const config = collectLlmConfig();
          if (config.provider === "none") {
            setLlmStatus("Select an LLM provider first.", true);
            llmConnected = false;
            updateLlmTabs();
            return;
          }
          await api("/api/chat", {
            method: "POST",
            body: JSON.stringify({ prompt: "Reply with OK.", ...config }),
          });
          llmConnected = true;
          setLlmStatus("Connected.");
        } catch (e) {
          llmConnected = false;
          setLlmStatus(e && e.message ? e.message : "Not connected.", true);
        } finally {
          updateLlmTabs();
          btn.disabled = false;
          btn.textContent = llmConnected ? "Disconnect" : "Connect";
        }
      });

      $("btnChatSend").addEventListener("click", async () => {
        try {
          const prompt = $("chatPrompt").value.trim();
          if (!prompt) {
            setOutput("Enter a message first.", true);
            return;
          }
          setOutput("Sending...");
          const images = await readImages("chatImages");
          const data = await api("/api/chat", {
            method: "POST",
            body: JSON.stringify({ prompt, images, ...collectLlmConfig() }),
          });
          setOutput(data && data.text ? data.text : "(empty response)");
        } catch (e) {
          setOutput(e && e.message ? e.message : String(e), true);
        }
      });

      (async () => {
        try {
          await api("/api/health", { method: "GET" });
          await loadPrompts();
          initWorkspaces();
          wireCustom("duration", "durationCustom");
          wireCustom("resolution", "resolutionCustom");
          wireCustom("aspect", "aspectCustom");
          const chatImagesEl = $("chatImages");
          if (chatImagesEl) {
            chatImagesEl.addEventListener("change", () => handleImagePick("chatImages", "chatImagesList"));
          }
          const promptImagesEl = $("promptImages");
          if (promptImagesEl) {
            promptImagesEl.addEventListener("change", () => handleImagePick("promptImages", "promptImagesList"));
          }
          const videoPartsEl = $("videoParts");
          if (videoPartsEl) {
            videoPartsEl.addEventListener("change", () => {
              renderFilesList("videoParts", "videoPartsList", "Remove video");
              const status = $("videoStatus");
              if (status) status.textContent = "";
              clearVideoPreview();
            });
          }
          const promptFieldIds = [
            "promptName",
            "story",
            "mode",
            "duration",
            "durationCustom",
            "resolution",
            "resolutionCustom",
            "aspect",
            "aspectCustom",
            "partLengthSeconds",
            "style",
            "camera",
            "lighting",
            "actionBeats",
            "quality",
            "audio",
          ];
          for (const id of promptFieldIds) {
            const el = $(id);
            if (!el) continue;
            el.addEventListener("input", saveActiveWorkspaceFields);
            el.addEventListener("change", saveActiveWorkspaceFields);
          }
          if ($("workspaceTabs")) {
            $("workspaceTabs").addEventListener("dblclick", () => {
              const ws = getActiveWorkspace();
              if (!ws) return;
              const next = prompt("Workspace name:", ws.name);
              if (!next) return;
              ws.name = next.trim();
              renderWorkspaceTabs();
              saveWorkspaces();
            });
          }

          const providerEl = $("provider");
          const cmdEl = $("providerCommand");
          const cmdPresetEl = $("commandPreset");
          const cmdCustomEl = $("commandCustom");
          const codexModelRowEl = $("codexModelRow");
          const codexSessionRowEl = $("codexSessionRow");
          const codexModelPresetEl = $("codexModelPreset");
          const codexModelCustomEl = $("codexModelCustom");
          const codexNewTopicEl = $("btnCodexNewTopic");
          const codexSessionModeEl = $("codexSessionMode");
          const geminiModelRowEl = $("geminiModelRow");
          const geminiModelPresetEl = $("geminiModelPreset");
          const geminiModelCustomEl = $("geminiModelCustom");
          const ollamaEl = $("providerOllama");
          const openaiEl = $("providerOpenAi");
          const updateCommandPreset = () => {
            if (!cmdPresetEl || !cmdCustomEl || !codexModelRowEl || !codexSessionRowEl || !geminiModelRowEl)
              return;
            const isCustom = cmdPresetEl.value === "custom";
            const isCodex = cmdPresetEl.value === "codex";
            const isGemini = cmdPresetEl.value === "gemini";
            const isAgent = cmdPresetEl.value === "agent";
            cmdCustomEl.style.display = isCustom ? "block" : "none";
            codexModelRowEl.style.display = isCodex ? "block" : "none";
            codexSessionRowEl.style.display = isCodex ? "block" : "none";
            geminiModelRowEl.style.display = isGemini ? "block" : "none";
            if (isGemini) {
              updateGeminiModelPreset();
            }
          };
          const updateGeminiModelPreset = () => {
            if (!geminiModelPresetEl || !geminiModelCustomEl) return;
            geminiModelCustomEl.style.display = geminiModelPresetEl.value === "custom" ? "block" : "none";
          };
          const updateCodexModelPreset = () => {
            if (!codexModelPresetEl || !codexModelCustomEl) return;
            codexModelCustomEl.style.display = codexModelPresetEl.value === "custom" ? "block" : "none";
          };
          const updateProvider = () => {
            cmdEl.style.display = providerEl.value === "command" ? "block" : "none";
            ollamaEl.style.display = providerEl.value === "ollama" ? "block" : "none";
            openaiEl.style.display = providerEl.value === "openai_compatible" ? "block" : "none";
            llmConnected = false;
            updateLlmTabs();
          };
          providerEl.addEventListener("change", updateProvider);
          if (cmdPresetEl) {
            cmdPresetEl.addEventListener("change", updateCommandPreset);
          }
          if (codexModelPresetEl) {
            codexModelPresetEl.addEventListener("change", updateCodexModelPreset);
          }
          if (geminiModelPresetEl) {
            geminiModelPresetEl.addEventListener("change", updateGeminiModelPreset);
          }
          if ($("compressImages")) {
            $("compressImages").addEventListener("change", () => saveSettings(captureSettings()));
          }
          if (codexNewTopicEl && codexSessionModeEl) {
            codexNewTopicEl.addEventListener("click", () => {
              codexSessionModeEl.value = "new";
              saveSettings(captureSettings());
            });
          }
          applySettings(loadSettings());
          updateProvider();
          updateCommandPreset();
          updateCodexModelPreset();
          updateGeminiModelPreset();
          const previewEl = $("outputPreview");
          if (previewEl) previewEl.textContent = PREVIEW_TEMPLATE;
          setOutputTab("preview");
          setLlmStatus("Server connected. Click Connect to test LLM.");
          llmConnected = false;
          updateLlmTabs();

          setOutput("Connected. Choose a prompt and click “Get prompt template”.");
        } catch (e) {
          llmConnected = false;
          updateLlmTabs();
          setLlmStatus("Not connected.", true);
          setOutput(
            "GUI server is up, but MCP bridge is not ready. Did you run `npm run build`?\n\n" +
              (e && e.message ? e.message : String(e)),
            true
          );
        }
      })();
    </script>
  </body>
</html>
